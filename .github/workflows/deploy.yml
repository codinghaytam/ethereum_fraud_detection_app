name: Deploy to EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [ closed ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH with PEM key
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Write PEM key with proper formatting
        echo "${{ secrets.EC2_PEM_KEY }}" | tr -d '\r' > ~/.ssh/ec2-key.pem
        
        # Set correct permissions for PEM key
        chmod 400 ~/.ssh/ec2-key.pem
        
        # Verify key format
        if ! ssh-keygen -l -f ~/.ssh/ec2-key.pem > /dev/null 2>&1; then
          echo "PEM key format verification failed"
          exit 1
        fi
        
        # Add host to known_hosts
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        
        # Test SSH connection with PEM key
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i ~/.ssh/ec2-key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful with PEM key'"

    - name: Create deployment package
      run: |
        # Create optimized deployment package - exclude data folder and sensitive files
        rm -f deployment.tar.gz
        
        # Create tar excluding data folder and other unnecessary files
        tar --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.github' \
            --exclude='*.log' \
            --exclude='data' \
            --exclude='data/' \
            --exclude='cosmoscan-eth-main/node_modules' \
            --exclude='cosmoscan-eth-main/dist' \
            --exclude='backend/target' \
            --exclude='backendApi/__pycache__' \
            --exclude='backendApi/apiEnv' \
            --exclude='training-env' \
            --exclude='**/.DS_Store' \
            --exclude='**/npm-debug.log*' \
            --exclude='*.png' \
            --exclude='*.pth' \
            --exclude='*.npy' \
            --exclude='deployment.tar.gz' \
            --exclude='.env' \
            --exclude='**/.env' \
            -czf deployment.tar.gz . || { 
              echo "Retrying tar creation with less strict checking..."
              tar --exclude='.git' \
                  --exclude='node_modules' \
                  --exclude='.github' \
                  --exclude='*.log' \
                  --exclude='data' \
                  --exclude='data/' \
                  --exclude='cosmoscan-eth-main/node_modules' \
                  --exclude='cosmoscan-eth-main/dist' \
                  --exclude='backend/target' \
                  --exclude='backendApi/__pycache__' \
                  --exclude='backendApi/apiEnv' \
                  --exclude='training-env' \
                  --exclude='**/.DS_Store' \
                  --exclude='**/npm-debug.log*' \
                  --exclude='*.png' \
                  --exclude='*.pth' \
                  --exclude='*.npy' \
                  --exclude='deployment.tar.gz' \
                  --exclude='.env' \
                  --exclude='**/.env' \
                  --ignore-failed-read \
                  -czf deployment.tar.gz . 2>/dev/null || true
            }
        
        # Verify the tar file was created
        if [ -f deployment.tar.gz ]; then
          echo "Deployment package created (excluding data folder)"
          ls -lh deployment.tar.gz
        else
          echo "Failed to create deployment package"
          exit 1
        fi

    - name: Copy files to EC2
      run: |
        # Copy deployment package to EC2 with PEM key
        scp -i ~/.ssh/ec2-key.pem deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/ 
        echo "Deployment package copied to EC2 successfully"

    - name: Deploy on EC2
      run: |
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2-key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
        set -e
        
        DEPLOY_DIR="/home/${{ secrets.EC2_USER }}/ethereum-fraud-detection"
        
        echo "Setting up deployment directory..."
        mkdir -p $DEPLOY_DIR
        
        # Backup current deployment
        if [ -d "$DEPLOY_DIR/current" ]; then
          echo "Backing up current deployment..."
          mv $DEPLOY_DIR/current $DEPLOY_DIR/backup-$(date +%Y%m%d-%H%M%S)
          # Keep only last 3 backups
          ls -dt $DEPLOY_DIR/backup-* | tail -n +4 | xargs rm -rf || true
        fi
        
        # Extract new deployment
        echo "Extracting new deployment..."
        mkdir -p $DEPLOY_DIR/current
        tar -xzf /tmp/deployment.tar.gz -C $DEPLOY_DIR/current
        cd $DEPLOY_DIR/current
        
        # Install Docker and Docker Compose if not present
        if ! command -v docker &> /dev/null; then
          echo "Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ${{ secrets.EC2_USER }}
          rm get-docker.sh
          # Add user to docker group for current session
          newgrp docker || true
        fi
        
        if ! command -v docker-compose &> /dev/null; then
          echo "Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
        fi
        
        # Create FastAPI environment file
        echo "Creating FastAPI environment configuration..."
        mkdir -p ./backendApi
        cat > ./backendApi/.env << 'FASTAPI_ENV'
        ETHERSCAN_API_KEY=${{ secrets.ETHERSCAN_API_KEY }}
        DEBUG=false
        LOG_LEVEL=INFO
        MODEL_DIR=/app/model
        PYTHONPATH=/app
        FASTAPI_ENV
        
        # Create frontend environment variables
        echo "Creating frontend environment configuration..."
        mkdir -p ./cosmoscan-eth-main
        cat > ./cosmoscan-eth-main/.env << 'FRONTEND_ENV'
        VITE_API_URL=http://${{ secrets.EC2_HOST }}:8000
        VITE_BACKEND_URL=http://${{ secrets.EC2_HOST }}:8080
        FRONTEND_ENV
        
        # Create backend application properties
        echo "Creating backend environment configuration..."
        mkdir -p ./backend/src/main/resources
        cat > ./backend/src/main/resources/application-docker.properties << 'BACKEND_ENV'
        # Server configuration
        server.port=8080
        server.servlet.context-path=/
        
        # CORS configuration
        app.cors.allowed-origins=http://${{ secrets.EC2_HOST }}:3000,http://localhost:3000
        app.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
        app.cors.allowed-headers=*
        app.cors.allow-credentials=true
        
        # Logging
        logging.level.com.example.demo=INFO
        logging.level.org.springframework=INFO
        
        # FastAPI service URL
        app.fastapi.url=http://fastapi:8000
        BACKEND_ENV
        
        # Create Docker Compose environment file
        cat > .env << 'DOCKER_ENV'
        # Service ports
        FRONTEND_PORT=3000
        BACKEND_PORT=8080
        FASTAPI_PORT=8000
        
        # Frontend URLs
        VITE_API_URL=http://${{ secrets.EC2_HOST }}:8000
        VITE_BACKEND_URL=http://${{ secrets.EC2_HOST }}:8080
        
        # Spring profiles
        SPRING_PROFILES_ACTIVE=docker
        
        # Model directory
        MODEL_DIR=/app/model
        PYTHONPATH=/app
        DOCKER_ENV
        
        echo "Stopping existing containers..."
        docker-compose down --remove-orphans || true
        
        echo "Cleaning up Docker resources..."
        docker system prune -f || true
        
        echo "Building and starting services with Docker Compose..."
        docker-compose up --build -d --remove-orphans
        
        echo "Waiting for services to initialize..."
        sleep 60
        
        # Health check function
        check_service() {
          local service_name=$1
          local url=$2
          local max_attempts=12
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f $url > /dev/null 2>&1; then
              echo "$service_name is healthy"
              return 0
            fi
            echo "Attempt $attempt/$max_attempts: $service_name not ready, waiting..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "$service_name failed health check"
          docker-compose logs $service_name
          return 1
        }
        
        echo "Performing health checks..."
        check_service "FastAPI" "http://localhost:8000/"
        check_service "Frontend" "http://localhost:3000/"
        
        # Backend health check
        echo "Checking Spring Boot backend..."
        if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
          echo "Spring Boot backend is running"
        else
          echo "Spring Boot backend might still be starting..."
          docker-compose logs backend | tail -30
        fi
        
        # Show running containers
        echo "Running containers:"
        docker-compose ps
        
        # Show service logs for debugging
        echo "Recent service logs:"
        docker-compose logs --tail=20
        
        rm -f /tmp/deployment.tar.gz
        echo "Deployment completed successfully!"
        EOF

    - name: Verify external deployment
      run: |
        echo "Verifying external access..."
        sleep 20
        
        # Check FastAPI
        if curl -f --connect-timeout 15 http://${{ secrets.EC2_HOST }}:8000/ > /dev/null 2>&1; then
          echo "‚úÖ FastAPI accessible externally"
        else
          echo "‚ùå FastAPI not accessible externally"
        fi
        
        # Check Frontend
        if curl -f --connect-timeout 15 http://${{ secrets.EC2_HOST }}:3000/ > /dev/null 2>&1; then
          echo "‚úÖ Frontend accessible externally" 
        else
          echo "‚ùå Frontend not accessible externally"
        fi
        
        # Check Backend
        if curl -f --connect-timeout 15 http://${{ secrets.EC2_HOST }}:8080/actuator/health > /dev/null 2>&1; then
          echo "‚úÖ Backend accessible externally"
        else
          echo "‚ö†Ô∏è  Backend not accessible externally (might still be starting)"
        fi

    - name: Security group reminder
      if: failure()
      run: |
        echo "‚ö†Ô∏è  If services are not accessible, check EC2 Security Group settings:"
        echo "   - Port 3000 (Frontend) should be open to 0.0.0.0/0"
        echo "   - Port 8080 (Backend) should be open to 0.0.0.0/0"  
        echo "   - Port 8000 (FastAPI) should be open to 0.0.0.0/0"
        echo "   - Port 22 (SSH) should be open for deployment"
        echo ""
        echo "üîë Make sure your EC2_PEM_KEY secret contains the complete .pem file content"

    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/ec2-key.pem
        rm -f deployment.tar.gz

    - name: Deployment notification
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "üéâ Deployment successful!"
          echo "üì± Frontend:  http://${{ secrets.EC2_HOST }}:3000"
          echo "üîß Backend:   http://${{ secrets.EC2_HOST }}:8080"
          echo "ü§ñ FastAPI:   http://${{ secrets.EC2_HOST }}:8000"
          echo "üìñ API Docs:  http://${{ secrets.EC2_HOST }}:8000/docs"
          echo ""
          echo "üîç Health endpoints:"
          echo "   Backend Health: http://${{ secrets.EC2_HOST }}:8080/actuator/health"
        else
          echo "‚ùå Deployment failed!"
          echo "Check the logs above for more details."
          echo "Common issues:"
          echo "  - Verify EC2_PEM_KEY secret is correctly formatted"
          echo "  - Check EC2 security group settings"
          echo "  - Ensure EC2 instance has sufficient resources"
        fi


    - name: Create deployment package
      run: |
        # Create optimized deployment package - only include necessary files for Docker Compose
        # Remove existing deployment package if it exists
        rm -f deployment.tar.gz
        
        # Create tar with error handling
        tar --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.github' \
            --exclude='*.log' \
            --exclude='cosmoscan-eth-main/node_modules' \
            --exclude='cosmoscan-eth-main/dist' \
            --exclude='backend/target' \
            --exclude='backendApi/__pycache__' \
            --exclude='backendApi/apiEnv' \
            --exclude='training-env' \
            --exclude='**/.DS_Store' \
            --exclude='**/npm-debug.log*' \
            --exclude='*.png' \
            --exclude='*.pth' \
            --exclude='*.npy' \
            --exclude='deployment.tar.gz' \
            -czf deployment.tar.gz . || { 
              # If tar fails due to file changes, try without strict error checking
              echo "Retrying tar creation with less strict checking..."
              tar --exclude='.git' \
                  --exclude='node_modules' \
                  --exclude='.github' \
                  --exclude='*.log' \
                  --exclude='cosmoscan-eth-main/node_modules' \
                  --exclude='cosmoscan-eth-main/dist' \
                  --exclude='backend/target' \
                  --exclude='backendApi/__pycache__' \
                  --exclude='backendApi/apiEnv' \
                  --exclude='training-env' \
                  --exclude='**/.DS_Store' \
                  --exclude='**/npm-debug.log*' \
                  --exclude='*.png' \
                  --exclude='*.pth' \
                  --exclude='*.npy' \
                  --exclude='deployment.tar.gz' \
                  --ignore-failed-read \
                  -czf deployment.tar.gz . 2>/dev/null || true
            }
        
        # Verify the tar file was created
        if [ -f deployment.tar.gz ]; then
          echo "Deployment package created (Docker Compose approach)"
          ls -lh deployment.tar.gz
        else
          echo "Failed to create deployment package"
          exit 1
        fi

    - name: Copy files to EC2
      run: |
        # Copy deployment package to EC2 with retry logic
        scp -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_rsa deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/ || {
          echo "First SCP attempt failed, retrying in 5 seconds..."
          sleep 5
          scp -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_rsa deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/
        }
        echo "Deployment package copied to EC2 successfully"

    - name: Deploy on EC2
      run: |
        ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
        set -e
        
        DEPLOY_DIR="/home/${{ secrets.EC2_USER }}/ethereum-fraud-detection"
        
        echo "Setting up deployment directory..."
        mkdir -p $DEPLOY_DIR
        
        # Backup current deployment
        if [ -d "$DEPLOY_DIR/current" ]; then
          echo "Backing up current deployment..."
          mv $DEPLOY_DIR/current $DEPLOY_DIR/backup-$(date +%Y%m%d-%H%M%S)
          # Keep only last 3 backups
          ls -dt $DEPLOY_DIR/backup-* | tail -n +4 | xargs rm -rf || true
        fi
        
        # Extract new deployment
        echo "Extracting new deployment..."
        mkdir -p $DEPLOY_DIR/current
        tar -xzf /tmp/deployment.tar.gz -C $DEPLOY_DIR/current
        cd $DEPLOY_DIR/current
        
        # Install Docker and Docker Compose if not present
        if ! command -v docker &> /dev/null; then
          echo "Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ${{ secrets.EC2_USER }}
          rm get-docker.sh
        fi
        
        if ! command -v docker-compose &> /dev/null; then
          echo "Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
        fi
        
        # Create or update .env file
        echo "Creating environment configuration..."
        cat > ./backendApi/.env << 'ENVEOF'
        ETHERSCAN_API_KEY=${{ secrets.ETHERSCAN_API_KEY }}
        FRONTEND_PORT=3000
        BACKEND_PORT=8080
        FASTAPI_PORT=8000
        VITE_API_URL=http://${{ secrets.EC2_HOST }}:8000
        VITE_BACKEND_URL=http://${{ secrets.EC2_HOST }}:8080
        SPRING_PROFILES_ACTIVE=production
        DEBUG=false
        LOG_LEVEL=INFO
        MODEL_DIR=/app/model
        PYTHONPATH=/app
        ENVEOF
        
        echo "Stopping existing containers..."
        docker-compose down || true
        
        echo "Cleaning up Docker resources..."
        docker system prune -f || true
        
        echo "Building and starting services with Docker Compose..."
        docker-compose up --build -d --remove-orphans
        
        echo "Waiting for services to initialize..."
        sleep 45
        
        # Health check function
        check_service() {
          local service_name=$1
          local url=$2
          local max_attempts=10
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f $url > /dev/null 2>&1; then
              echo "$service_name is healthy"
              return 0
            fi
            echo "Attempt $attempt/$max_attempts: $service_name not ready, waiting..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "$service_name failed health check"
          docker-compose logs $service_name
          return 1
        }
        
        echo "Performing health checks..."
        check_service "FastAPI" "http://localhost:8000/"
        check_service "Frontend" "http://localhost:3000/"
        
        # Backend might take longer to start
        echo "Checking Spring Boot backend..."
        if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
          echo "Spring Boot backend is running"
        else
          echo "Spring Boot backend might still be starting..."
          docker-compose logs backend | tail -20
        fi
        
        # Show running containers
        echo "Running containers:"
        docker-compose ps
        
        rm -f /tmp/deployment.tar.gz
        echo "Deployment completed successfully!"
        EOF
    - name: Verify deployment
      run: |
        echo "Verifying external access..."
        sleep 15
        
        # Check FastAPI
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:8000/ > /dev/null 2>&1; then
          echo "‚úÖ FastAPI accessible externally"
        else
          echo "‚ùå FastAPI not accessible externally"
        fi
        
        # Check Frontend
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:3000/ > /dev/null 2>&1; then
          echo "‚úÖ Frontend accessible externally" 
        else
          echo "‚ùå Frontend not accessible externally"
        fi
        
        # Check Backend (might still be starting)
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:8080/actuator/health > /dev/null 2>&1; then
          echo "‚úÖ Backend accessible externally"
        else
          echo "‚ö†Ô∏è  Backend not accessible externally (might still be starting)"
        fi

    - name: Security group reminder
      if: failure()
      run: |
        echo "‚ö†Ô∏è  If services are not accessible, check EC2 Security Group settings:"
        echo "   - Port 3000 (Frontend) should be open to 0.0.0.0/0"
        echo "   - Port 8080 (Backend) should be open to 0.0.0.0/0"  
        echo "   - Port 8000 (FastAPI) should be open to 0.0.0.0/0"
        echo "   - Port 22 (SSH) should be open for deployment"

    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/id_rsa
        rm -f deployment.tar.gz

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "üéâ Deployment successful!"
          echo "üì± Frontend:  http://${{ secrets.EC2_HOST }}:3000"
          echo "üîß Backend:   http://${{ secrets.EC2_HOST }}:8080"
          echo "ü§ñ FastAPI:   http://${{ secrets.EC2_HOST }}:8000"
          echo "üìñ API Docs:  http://${{ secrets.EC2_HOST }}:8000/docs"
        else
          echo "‚ùå Deployment failed!"
          echo "Check the logs above for more details."
        fi
