name: Deploy to EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [ closed ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: cosmoscan-eth-main/package-lock.json

    - name: Install Docker Compose
      run: |
        # Install latest Docker Compose
        sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
        docker-compose --version

    - name: Build and Test with Docker Compose
      run: |
        # Use Docker Compose to build all services
        docker-compose build --parallel
        echo "All services built successfully with Docker Compose"

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts


  
    - name: Copy files to EC2
      run: |
        scp -i ~/.ssh/id_rsa deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/

    - name: Deploy on EC2
      run: |
        ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
        set -e
        
        DEPLOY_DIR="/home/${{ secrets.EC2_USER }}/ethereum-fraud-detection"
        
        echo "Setting up deployment directory..."
        mkdir -p $DEPLOY_DIR
        
        # Backup current deployment
        if [ -d "$DEPLOY_DIR/current" ]; then
          echo "Backing up current deployment..."
          mv $DEPLOY_DIR/current $DEPLOY_DIR/backup-$(date +%Y%m%d-%H%M%S)
          # Keep only last 3 backups
          ls -dt $DEPLOY_DIR/backup-* | tail -n +4 | xargs rm -rf || true
        fi
        
        # Extract new deployment
        echo "Extracting new deployment..."
        mkdir -p $DEPLOY_DIR/current
        tar -xzf /tmp/deployment.tar.gz -C $DEPLOY_DIR/current
        cd $DEPLOY_DIR/current
        
        # Install Docker and Docker Compose if not present
        if ! command -v docker &> /dev/null; then
          echo "Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ${{ secrets.EC2_USER }}
          rm get-docker.sh
        fi
        
        if ! command -v docker-compose &> /dev/null; then
          echo "Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
        fi
        
        # Create or update .env file
        echo "Creating environment configuration..."
        cat > ./backendApi/.env << 'ENVEOF'
        ETHERSCAN_API_KEY=${{ secrets.ETHERSCAN_API_KEY }}
        FRONTEND_PORT=3000
        BACKEND_PORT=8080
        FASTAPI_PORT=8000
        VITE_API_URL=http://${{ secrets.EC2_HOST }}:8000
        VITE_BACKEND_URL=http://${{ secrets.EC2_HOST }}:8080
        SPRING_PROFILES_ACTIVE=production
        DEBUG=false
        LOG_LEVEL=INFO
        MODEL_DIR=/app/model
        PYTHONPATH=/app
        ENVEOF
        
        echo "Stopping existing containers..."
        docker-compose down || true
        
        echo "Cleaning up Docker resources..."
        docker system prune -f || true
        
        echo "Building and starting services with Docker Compose..."
        docker-compose up --build -d --remove-orphans
        
        echo "Waiting for services to initialize..."
        sleep 45
        
        # Health check function
        check_service() {
          local service_name=$1
          local url=$2
          local max_attempts=10
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f $url > /dev/null 2>&1; then
              echo "$service_name is healthy"
              return 0
            fi
            echo "Attempt $attempt/$max_attempts: $service_name not ready, waiting..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "$service_name failed health check"
          docker-compose logs $service_name
          return 1
        }
        
        echo "Performing health checks..."
        check_service "FastAPI" "http://localhost:8000/"
        check_service "Frontend" "http://localhost:3000/"
        
        # Backend might take longer to start
        echo "Checking Spring Boot backend..."
        if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
          echo "Spring Boot backend is running"
        else
          echo "Spring Boot backend might still be starting..."
          docker-compose logs backend | tail -20
        fi
        
        # Show running containers
        echo "Running containers:"
        docker-compose ps
        
        rm -f /tmp/deployment.tar.gz
        echo "Deployment completed successfully!"
        EOF
    - name: Verify deployment
      run: |
        echo "Verifying external access..."
        sleep 15
        
        # Check FastAPI
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:8000/ > /dev/null 2>&1; then
          echo "‚úÖ FastAPI accessible externally"
        else
          echo "‚ùå FastAPI not accessible externally"
        fi
        
        # Check Frontend
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:3000/ > /dev/null 2>&1; then
          echo "‚úÖ Frontend accessible externally" 
        else
          echo "‚ùå Frontend not accessible externally"
        fi
        
        # Check Backend (might still be starting)
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:8080/actuator/health > /dev/null 2>&1; then
          echo "‚úÖ Backend accessible externally"
        else
          echo "‚ö†Ô∏è  Backend not accessible externally (might still be starting)"
        fi

    - name: Security group reminder
      if: failure()
      run: |
        echo "‚ö†Ô∏è  If services are not accessible, check EC2 Security Group settings:"
        echo "   - Port 3000 (Frontend) should be open to 0.0.0.0/0"
        echo "   - Port 8080 (Backend) should be open to 0.0.0.0/0"  
        echo "   - Port 8000 (FastAPI) should be open to 0.0.0.0/0"
        echo "   - Port 22 (SSH) should be open for deployment"

    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/id_rsa
        rm -f deployment.tar.gz

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "üéâ Deployment successful!"
          echo "üì± Frontend:  http://${{ secrets.EC2_HOST }}:3000"
          echo "üîß Backend:   http://${{ secrets.EC2_HOST }}:8080"
          echo "ü§ñ FastAPI:   http://${{ secrets.EC2_HOST }}:8000"
          echo "üìñ API Docs:  http://${{ secrets.EC2_HOST }}:8000/docs"
        else
          echo "‚ùå Deployment failed!"
          echo "Check the logs above for more details."
        fi
