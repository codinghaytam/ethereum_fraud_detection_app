name: Deploy to EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [ closed ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: cosmoscan-eth-main/package-lock.json

    - name: Install Docker Compose
      run: |
        # Install latest Docker Compose
        sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
        docker-compose --version

    - name: Build and Test with Docker Compose
      run: |
        # Use Docker Compose to build all services
        docker-compose build --parallel
        echo "All services built successfully with Docker Compose"

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Write SSH key with proper formatting
        echo "${{ secrets.EC2_SSH_KEY }}" | tr -d '\r' > ~/.ssh/id_rsa
        
        # Set correct permissions
        chmod 600 ~/.ssh/id_rsa
        
        # Verify key format
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          echo "SSH key format verification failed"
          exit 1
        fi
        
        # Add host to known_hosts
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        
        # Test SSH connection
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'"


    - name: Create deployment package
      run: |
        # Create optimized deployment package - only include necessary files for Docker Compose
        # Remove existing deployment package if it exists
        rm -f deployment.tar.gz
        
        # Create tar with error handling
        tar --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.github' \
            --exclude='*.log' \
            --exclude='cosmoscan-eth-main/node_modules' \
            --exclude='cosmoscan-eth-main/dist' \
            --exclude='backend/target' \
            --exclude='backendApi/__pycache__' \
            --exclude='backendApi/apiEnv' \
            --exclude='training-env' \
            --exclude='**/.DS_Store' \
            --exclude='**/npm-debug.log*' \
            --exclude='*.png' \
            --exclude='*.pth' \
            --exclude='*.npy' \
            --exclude='deployment.tar.gz' \
            -czf deployment.tar.gz . || { 
              # If tar fails due to file changes, try without strict error checking
              echo "Retrying tar creation with less strict checking..."
              tar --exclude='.git' \
                  --exclude='node_modules' \
                  --exclude='.github' \
                  --exclude='*.log' \
                  --exclude='cosmoscan-eth-main/node_modules' \
                  --exclude='cosmoscan-eth-main/dist' \
                  --exclude='backend/target' \
                  --exclude='backendApi/__pycache__' \
                  --exclude='backendApi/apiEnv' \
                  --exclude='training-env' \
                  --exclude='**/.DS_Store' \
                  --exclude='**/npm-debug.log*' \
                  --exclude='*.png' \
                  --exclude='*.pth' \
                  --exclude='*.npy' \
                  --exclude='deployment.tar.gz' \
                  --ignore-failed-read \
                  -czf deployment.tar.gz . 2>/dev/null || true
            }
        
        # Verify the tar file was created
        if [ -f deployment.tar.gz ]; then
          echo "Deployment package created (Docker Compose approach)"
          ls -lh deployment.tar.gz
        else
          echo "Failed to create deployment package"
          exit 1
        fi

    - name: Copy files to EC2
      run: |
        # Copy deployment package to EC2 with retry logic
        scp -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_rsa deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/ || {
          echo "First SCP attempt failed, retrying in 5 seconds..."
          sleep 5
          scp -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_rsa deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/tmp/
        }
        echo "Deployment package copied to EC2 successfully"

    - name: Deploy on EC2
      run: |
        ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
        set -e
        
        DEPLOY_DIR="/home/${{ secrets.EC2_USER }}/ethereum-fraud-detection"
        
        echo "Setting up deployment directory..."
        mkdir -p $DEPLOY_DIR
        
        # Backup current deployment
        if [ -d "$DEPLOY_DIR/current" ]; then
          echo "Backing up current deployment..."
          mv $DEPLOY_DIR/current $DEPLOY_DIR/backup-$(date +%Y%m%d-%H%M%S)
          # Keep only last 3 backups
          ls -dt $DEPLOY_DIR/backup-* | tail -n +4 | xargs rm -rf || true
        fi
        
        # Extract new deployment
        echo "Extracting new deployment..."
        mkdir -p $DEPLOY_DIR/current
        tar -xzf /tmp/deployment.tar.gz -C $DEPLOY_DIR/current
        cd $DEPLOY_DIR/current
        
        # Install Docker and Docker Compose if not present
        if ! command -v docker &> /dev/null; then
          echo "Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ${{ secrets.EC2_USER }}
          rm get-docker.sh
        fi
        
        if ! command -v docker-compose &> /dev/null; then
          echo "Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
        fi
        
        # Create or update .env file
        echo "Creating environment configuration..."
        cat > ./backendApi/.env << 'ENVEOF'
        ETHERSCAN_API_KEY=${{ secrets.ETHERSCAN_API_KEY }}
        FRONTEND_PORT=3000
        BACKEND_PORT=8080
        FASTAPI_PORT=8000
        VITE_API_URL=http://${{ secrets.EC2_HOST }}:8000
        VITE_BACKEND_URL=http://${{ secrets.EC2_HOST }}:8080
        SPRING_PROFILES_ACTIVE=production
        DEBUG=false
        LOG_LEVEL=INFO
        MODEL_DIR=/app/model
        PYTHONPATH=/app
        ENVEOF
        
        echo "Stopping existing containers..."
        docker-compose down || true
        
        echo "Cleaning up Docker resources..."
        docker system prune -f || true
        
        echo "Building and starting services with Docker Compose..."
        docker-compose up --build -d --remove-orphans
        
        echo "Waiting for services to initialize..."
        sleep 45
        
        # Health check function
        check_service() {
          local service_name=$1
          local url=$2
          local max_attempts=10
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f $url > /dev/null 2>&1; then
              echo "$service_name is healthy"
              return 0
            fi
            echo "Attempt $attempt/$max_attempts: $service_name not ready, waiting..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "$service_name failed health check"
          docker-compose logs $service_name
          return 1
        }
        
        echo "Performing health checks..."
        check_service "FastAPI" "http://localhost:8000/"
        check_service "Frontend" "http://localhost:3000/"
        
        # Backend might take longer to start
        echo "Checking Spring Boot backend..."
        if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
          echo "Spring Boot backend is running"
        else
          echo "Spring Boot backend might still be starting..."
          docker-compose logs backend | tail -20
        fi
        
        # Show running containers
        echo "Running containers:"
        docker-compose ps
        
        rm -f /tmp/deployment.tar.gz
        echo "Deployment completed successfully!"
        EOF
    - name: Verify deployment
      run: |
        echo "Verifying external access..."
        sleep 15
        
        # Check FastAPI
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:8000/ > /dev/null 2>&1; then
          echo "‚úÖ FastAPI accessible externally"
        else
          echo "‚ùå FastAPI not accessible externally"
        fi
        
        # Check Frontend
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:3000/ > /dev/null 2>&1; then
          echo "‚úÖ Frontend accessible externally" 
        else
          echo "‚ùå Frontend not accessible externally"
        fi
        
        # Check Backend (might still be starting)
        if curl -f --connect-timeout 10 http://${{ secrets.EC2_HOST }}:8080/actuator/health > /dev/null 2>&1; then
          echo "‚úÖ Backend accessible externally"
        else
          echo "‚ö†Ô∏è  Backend not accessible externally (might still be starting)"
        fi

    - name: Security group reminder
      if: failure()
      run: |
        echo "‚ö†Ô∏è  If services are not accessible, check EC2 Security Group settings:"
        echo "   - Port 3000 (Frontend) should be open to 0.0.0.0/0"
        echo "   - Port 8080 (Backend) should be open to 0.0.0.0/0"  
        echo "   - Port 8000 (FastAPI) should be open to 0.0.0.0/0"
        echo "   - Port 22 (SSH) should be open for deployment"

    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/id_rsa
        rm -f deployment.tar.gz

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "üéâ Deployment successful!"
          echo "üì± Frontend:  http://${{ secrets.EC2_HOST }}:3000"
          echo "üîß Backend:   http://${{ secrets.EC2_HOST }}:8080"
          echo "ü§ñ FastAPI:   http://${{ secrets.EC2_HOST }}:8000"
          echo "üìñ API Docs:  http://${{ secrets.EC2_HOST }}:8000/docs"
        else
          echo "‚ùå Deployment failed!"
          echo "Check the logs above for more details."
        fi
